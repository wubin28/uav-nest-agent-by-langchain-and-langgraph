# TODO: LangGraph智能路由RAG实施清单

**创建时间**: 2025-11-21 16:04  
**目标**: 创建`uav-nest-agent-agentic-rag.py`，实现阶段3的智能路由RAG系统  
**方案**: 方案C（混合智能路由）

---

## 实施清单

### ✅ 阶段1: 环境准备和依赖更新
- [ ] 1. 读取现有`requirements.txt`文件
- [ ] 2. 在`requirements.txt`末尾添加LangGraph依赖（langgraph>=0.2.0, langgraph-checkpoint>=0.2.0）
- [ ] 3. 保存更新后的`requirements.txt`

### ✅ 阶段2: 核心类和状态定义
- [ ] 4. 创建`uav-nest-agent-agentic-rag.py`文件
- [ ] 5. 添加文件头部文档字符串（说明阶段3的LangGraph实现目的）
- [ ] 6. 导入必要的库（LangChain、LangGraph、typing等）
- [ ] 7. 定义`GraphState` TypedDict类（包含question, question_type, target_sources, chunks, sources_used, iteration, is_sufficient, answer, route_decision字段）
- [ ] 8. 定义数据源配置常量`DATA_SOURCES`（复用阶段2的6个数据源配置）

### ✅ 阶段3: 初始化和向量库加载
- [ ] 9. 创建`AgenticRAGAgent`类
- [ ] 10. 实现`__init__`方法（接收API keys、向量库路径等参数，初始化基本属性）
- [ ] 11. 实现`_initialize_llms`方法（创建classifier_llm用deepseek-chat，generator_llm用deepseek-reasoner）
- [ ] 12. 实现`load_vector_stores`方法（连接./tmp/lancedb/，加载6个向量库表，创建6个retrievers）

### ✅ 阶段4: 图节点实现 - 问题分类
- [ ] 13. 实现`classify_question`节点方法（使用LLM分类为basic_info/technical/comparison，设置target_sources，记录route_decision）

### ✅ 阶段5: 图节点实现 - 并行检索
- [ ] 14. 实现`retrieve_parallel`节点方法（使用ThreadPoolExecutor并行查询target_sources中的数据源，合并chunks，统计sources_used）

### ✅ 阶段6: 图节点实现 - 信息充分性检查
- [ ] 15. 实现`check_sufficiency`节点方法（检查chunks数量是否>=3，设置is_sufficient标志）

### ✅ 阶段7: 图节点实现 - 扩展数据源
- [ ] 16. 实现`expand_sources`节点方法（根据iteration次数逐级扩展数据源：P1→P2→P3→全部，更新target_sources）

### ✅ 阶段8: 图节点实现 - 生成答案
- [ ] 17. 实现`generate_answer`节点方法（格式化chunks为context，使用generator_llm生成带内联标注的答案）

### ✅ 阶段9: 辅助方法实现
- [ ] 18. 实现`format_docs_with_source`静态方法（按数据源分组chunks，为每个chunk添加来源标注）
- [ ] 19. 实现`route_after_check`条件边函数（根据is_sufficient和iteration决定下一步节点）

### ✅ 阶段10: 构建LangGraph图
- [ ] 20. 实现`build_graph`方法（创建StateGraph，添加6个节点，设置边连接和条件边，编译图）

### ✅ 阶段11: 输出格式化
- [ ] 21. 实现`format_output`节点方法（生成分层展示输出：问题→路由决策→检索结果→答案）

### ✅ 阶段12: 运行接口
- [ ] 22. 实现`ask`方法（初始化GraphState，执行compiled_graph，返回最终state）
- [ ] 23. 实现`print_result`方法（美化打印分层输出，显示数据源使用统计）

### ✅ 阶段13: Mermaid可视化
- [ ] 24. 实现`visualize_graph`方法（使用graph.get_graph().draw_mermaid()生成工作流图，保存到agentic-rag-workflow.mmd）

### ✅ 阶段14: 演示模式实现
- [ ] 25. 实现`run_demo`方法（顺序执行3个预设问题，打印分隔线，统计总耗时）
- [ ] 26. 实现交互模式（可选，询问用户是否继续，循环接收输入）

### ✅ 阶段15: Main函数
- [ ] 27. 实现`main`函数（初始化Agent，加载向量库，构建图，生成可视化，运行演示，打印总结）

### ✅ 阶段16: 测试和验证
- [ ] 28. 添加`if __name__ == "__main__":`入口
- [ ] 29. 确保所有导入路径正确
- [ ] 30. 添加详细注释说明LangGraph特性（条件边、并行节点、状态管理）

---

## 核心技术点清单

### 必须展示的LangGraph特性：
- ✅ 条件边（Conditional Edges）: check_sufficiency → route_after_check
- ✅ 并行节点（Parallel Execution）: retrieve_parallel中的并发检索
- ✅ 状态管理（State Management）: GraphState跟踪整个流程
- ✅ 循环逻辑（Cycles）: expand_sources → retrieve_parallel的补充查询循环

### 数据源路由规则：
- basic_info → P3 (2个官网)
- technical → P1 (2个白皮书)
- comparison → P2+P3 (4个手册+官网)

### 补充查询策略：
- 初始查询 chunks < 3 → 触发补充
- 第1次补充: 添加相邻优先级源
- 第2次补充: 添加所有6个源
- 最多3次迭代

### 双模型策略：
- classifier_llm: deepseek-chat (快速分类)
- generator_llm: deepseek-reasoner (高质量答案)

### 信息源标注格式：
```
传输速度为150-200 MB/s [来源: EVO Nest技术白皮书, Page 3]
```

---

## 3个测试问题

1. **Q1 (基础信息)**: "Autel EVO Nest机巢和Dji Dock机场分别支持哪些无人机型号？"
   - 预期路由: P3官网
   - 预期数据源: 2个

2. **Q2 (技术细节)**: "Autel EVO Nest机巢和Dji Dock机场各自的数据传输速度是多少？"
   - 预期路由: P1白皮书
   - 预期数据源: 2个

3. **Q3 (对比分析)**: "与DJI Dock机场相比，Autel EVO Nest机巢的优势在哪？"
   - 预期路由: P2+P3手册+官网
   - 预期数据源: 4个

---

## 预期输出文件

1. `uav-nest-agent-agentic-rag.py` - 主程序（约600-700行）
2. `requirements.txt` - 更新后的依赖文件
3. `agentic-rag-workflow.mmd` - Mermaid工作流图（运行时生成）

---

## 实施注意事项

- ⚠️ 复用现有向量库（./tmp/lancedb/），不重新创建
- ⚠️ 确保内联标注格式在Prompt中明确要求
- ⚠️ 并行检索使用ThreadPoolExecutor而非asyncio（兼容性更好）
- ⚠️ 条件边函数必须返回字符串（节点名称）
- ⚠️ 所有节点方法必须接收GraphState并返回更新后的GraphState
- ⚠️ 在关键决策点打印日志，便于观察路由过程

---

**状态**: 待执行  
**预计行数**: 600-700行  
**预计完成时间**: EXECUTE模式约需执行30个工作项

