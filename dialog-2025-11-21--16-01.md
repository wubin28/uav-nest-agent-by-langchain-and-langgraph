## Me:

```
在进入PLAN模式之前，请确认：

1. ✅ **是否采用方案C（混合智能路由）？**
2. ✅ **是否采用分层展示方案来清晰标注信息源？**
3. ✅ **是否使用双模型策略（chat做分类，reasoner做答案）？**
4. ✅ **是否需要生成Mermaid工作流可视化图？**
5. ✅ **是否包含3个预设问题的演示模式？**

回答：我对以上5个问题的回复全部都是“是”。ENTER PLAN MODE
```

## Cursor with claude sonnet 4.5:

```
[MODE: PLAN]

完美！您已确认采用**方案C（混合智能路由）**及所有配套方案。现在我将创建详尽的实施计划。

---

## 📋 LangGraph智能路由RAG - 完整实施计划

### 🎯 实施目标
创建`uav-nest-agent-agentic-rag.py`，实现智能路由RAG系统，能够：
1. 使用LLM智能分类问题类型
2. 根据问题类型自动路由到相应数据源
3. 并行查询多个数据源
4. 自动补充查询（如果信息不足）
5. 清晰标注信息源出处

---

## 🏗️ 系统架构设计

### 1. GraphState状态结构
```python
class GraphState(TypedDict):
    question: str                    # 原始问题
    question_type: str              # 问题分类: basic_info/technical/comparison
    target_sources: List[str]       # 目标数据源列表
    chunks: List[Document]          # 检索到的文档chunks
    sources_used: Dict[str, int]    # 使用的数据源统计 {source_name: chunk_count}
    iteration: int                  # 迭代次数（用于补充查询）
    is_sufficient: bool             # 信息是否充分
    answer: str                     # 最终答案
    route_decision: str             # 路由决策记录（用于可视化）
```

### 2. LangGraph节点设计

| 节点名称 | 功能 | 输入 | 输出 | LLM调用 |
|---------|------|------|------|---------|
| `classify_question` | 问题分类 | question | question_type, target_sources | deepseek-chat |
| `retrieve_parallel` | 并行检索 | target_sources, question | chunks, sources_used | 无 |
| `check_sufficiency` | 检查信息充分性 | chunks | is_sufficient | 无（规则判断） |
| `expand_sources` | 扩展数据源 | target_sources, iteration | updated target_sources | 无 |
| `generate_answer` | 生成答案 | question, chunks, sources_used | answer | deepseek-reasoner |
| `format_output` | 格式化输出 | answer, route_decision, sources_used | formatted_output | 无 |

### 3. 条件边逻辑

```python
# 从 check_sufficiency 出发的条件边
def route_after_sufficiency_check(state: GraphState) -> str:
    if state["is_sufficient"]:
        return "generate_answer"
    elif state["iteration"] < 3:  # 最多补充2次
        return "expand_sources"
    else:
        return "generate_answer"  # 超过3次迭代，强制生成答案
```

### 4. 问题分类规则（LLM Prompt）

```python
CLASSIFICATION_PROMPT = """
你是一个智能问题分类器。请分析以下问题，判断其类型。

问题类型定义：
1. basic_info (基础信息查询): 询问产品型号、支持设备、基本参数等
2. technical (技术细节查询): 询问技术规格、传输速度、存储容量等具体技术参数
3. comparison (对比分析查询): 对比两个产品的优劣、差异、特点等

问题: {question}

请只返回以下之一: basic_info, technical, comparison
"""
```

### 5. 数据源路由规则

| 问题类型 | 目标数据源 | 优先级 |
|---------|-----------|-------|
| basic_info | evo_nest_webpage, dji_dock_webpage | P3 |
| technical | evo_nest_whitepaper, dji_dock_whitepaper | P1 |
| comparison | evo_nest_manual, dji_dock_manual, evo_nest_webpage, dji_dock_webpage | P2+P3 |

### 6. 补充查询策略

```
初始查询失败 (chunks < 3)
    ↓
第1次补充: 添加相邻优先级源
    - basic_info → 添加P2 (手册)
    - technical → 添加P2 (手册)
    - comparison → 添加P1 (白皮书)
    ↓
第2次补充: 添加所有源
    - 查询全部6个数据源
```

---

## 📝 实施清单

### 阶段1: 环境准备和依赖更新
1. 读取现有`requirements.txt`文件
2. 在`requirements.txt`末尾添加LangGraph依赖：
   ```
   # LangGraph Dependencies (Stage 3)
   langgraph>=0.2.0,<0.3.0
   langgraph-checkpoint>=0.2.0,<0.3.0
   ```
3. 保存更新后的`requirements.txt`

### 阶段2: 核心类和状态定义
4. 创建`uav-nest-agent-agentic-rag.py`文件
5. 添加文件头部文档字符串（说明这是阶段3的LangGraph实现）
6. 导入必要的库：
   - LangChain核心组件
   - LangGraph组件 (StateGraph, END)
   - typing (TypedDict)
   - 其他工具库
7. 定义`GraphState` TypedDict类（包含所有状态字段）
8. 定义数据源配置常量`DATA_SOURCES`（复用阶段2的配置）

### 阶段3: 初始化和向量库加载
9. 创建`AgenticRAGAgent`类
10. 实现`__init__`方法：
    - 接收API keys、向量库路径等参数
    - 初始化两个LLM（chat和reasoner）
    - 初始化embeddings（FastEmbed）
11. 实现`_initialize_llms`方法：
    - 创建`self.classifier_llm` (deepseek-chat, temperature=0)
    - 创建`self.generator_llm` (deepseek-reasoner, temperature=0)
12. 实现`load_vector_stores`方法：
    - 连接到`./tmp/lancedb/`
    - 加载6个已存在的向量库表
    - 创建6个retrievers（每个k=5）
    - 将retrievers存储到字典中

### 阶段4: 图节点实现 - 问题分类
13. 实现`classify_question`节点方法：
    - 使用`CLASSIFICATION_PROMPT`
    - 调用`classifier_llm`进行分类
    - 解析返回的问题类型（basic_info/technical/comparison）
    - 根据分类结果设置`target_sources`列表
    - 记录路由决策到`route_decision`字段
    - 返回更新后的state

### 阶段5: 图节点实现 - 并行检索
14. 实现`retrieve_parallel`节点方法：
    - 遍历`target_sources`列表
    - 为每个数据源创建异步检索任务
    - 使用Python的`concurrent.futures`并行执行检索
    - 合并所有检索结果到`chunks`列表
    - 统计每个数据源的chunk数量到`sources_used`字典
    - 打印检索日志（展示每个源的chunk数）
    - 返回更新后的state

### 阶段6: 图节点实现 - 信息充分性检查
15. 实现`check_sufficiency`节点方法：
    - 检查`chunks`列表长度
    - 如果`len(chunks) >= 3`，设置`is_sufficient = True`
    - 否则设置`is_sufficient = False`
    - 打印判断结果和原因
    - 返回更新后的state

### 阶段7: 图节点实现 - 扩展数据源
16. 实现`expand_sources`节点方法：
    - 读取当前`iteration`和`question_type`
    - 增加`iteration`计数
    - 根据迭代次数扩展数据源：
      - iteration=1: 添加相邻优先级源
      - iteration=2: 添加所有6个源
    - 更新`target_sources`列表
    - 打印扩展决策日志
    - 返回更新后的state，流程回到`retrieve_parallel`

### 阶段8: 图节点实现 - 生成答案
17. 实现`generate_answer`节点方法：
    - 使用`format_docs_with_source`辅助函数格式化chunks
    - 构建answer generation prompt：
      - 包含问题
      - 包含格式化的context（按数据源分组）
      - 要求内联标注信息源
    - 调用`generator_llm`生成答案
    - 将答案存储到`answer`字段
    - 返回更新后的state

### 阶段9: 辅助方法实现
18. 实现`format_docs_with_source`静态方法：
    - 按数据源分组chunks
    - 为每个chunk添加来源标注（source_name, page）
    - 返回格式化的字符串
19. 实现`route_after_check`条件边函数：
    - 根据`is_sufficient`和`iteration`决定下一步
    - 返回节点名称字符串

### 阶段10: 构建LangGraph图
20. 实现`build_graph`方法：
    - 创建`StateGraph`实例
    - 添加6个节点：
      - classify_question
      - retrieve_parallel
      - check_sufficiency
      - expand_sources
      - generate_answer
      - format_output
    - 添加边：
      - START → classify_question
      - classify_question → retrieve_parallel
      - retrieve_parallel → check_sufficiency
      - check_sufficiency → (条件边) → generate_answer/expand_sources
      - expand_sources → retrieve_parallel
      - generate_answer → format_output
      - format_output → END
    - 编译图并返回

### 阶段11: 输出格式化
21. 实现`format_output`节点方法：
    - 生成分层展示的输出：
      ```
      【问题】
      【路由决策】
      【检索结果】
      【答案】
      ```
    - 返回最终state

### 阶段12: 运行接口
22. 实现`ask`方法：
    - 接收question参数
    - 初始化GraphState
    - 调用compiled_graph执行
    - 返回最终state
23. 实现`print_result`方法：
    - 接收state参数
    - 美化打印分层输出
    - 显示数据源使用情况

### 阶段13: Mermaid可视化
24. 实现`visualize_graph`方法：
    - 使用`graph.get_graph().draw_mermaid()`
    - 生成Mermaid图字符串
    - 保存到文件`agentic-rag-workflow.mmd`
    - 打印Mermaid代码（可复制到在线编辑器）

### 阶段14: 演示模式实现
25. 实现`run_demo`方法：
    - 定义3个预设问题列表
    - 依次执行每个问题
    - 在每个问题之间打印分隔线
    - 统计总耗时
26. 实现交互模式（可选）：
    - 询问用户是否继续交互
    - 循环接收用户输入
    - 处理退出命令

### 阶段15: Main函数
27. 实现`main`函数：
    - 打印欢迎信息
    - 初始化AgenticRAGAgent
    - 加载向量库
    - 构建LangGraph图
    - 生成Mermaid可视化
    - 运行3个预设问题演示
    - 打印完成信息和学习要点总结

### 阶段16: 测试和验证
28. 添加`if __name__ == "__main__":`入口
29. 确保所有导入路径正确
30. 添加详细的注释说明LangGraph特性

### 阶段17: 创建TODO文件
31. 创建`todo-2025-11-21--16-04.md`文件
32. 将上述30个工作项写入TODO文件
33. 添加文档头部说明

---

## 🎨 关键技术细节

### Prompt模板设计

**问题分类Prompt**:
```python
CLASSIFICATION_PROMPT = """你是一个智能问题分类器...
[详细prompt见上文]
"""
```

**答案生成Prompt**:
```python
ANSWER_PROMPT = """你是一个专业的无人机产品对比分析专家...

请根据以下产品文档回答问题。重要：必须在答案中使用内联标注格式。

标注格式示例:
- 传输速度为150-200 MB/s [来源: EVO Nest技术白皮书, Page 3]
- 支持EVO II系列无人机 [来源: EVO Nest官网]

产品文档：
{context}

问题：{question}

请提供详细回答，并确保每个关键信息都标注来源。
"""
```

### 并行检索实现方案
```python
from concurrent.futures import ThreadPoolExecutor

def retrieve_parallel(state: GraphState) -> GraphState:
    chunks = []
    sources_used = {}
    
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = {}
        for source_id in state["target_sources"]:
            retriever = self.retrievers[source_id]
            future = executor.submit(
                retriever.get_relevant_documents,
                state["question"]
            )
            futures[future] = source_id
        
        for future in concurrent.futures.as_completed(futures):
            source_id = futures[future]
            docs = future.result()
            chunks.extend(docs)
            sources_used[source_id] = len(docs)
    
    return {**state, "chunks": chunks, "sources_used": sources_used}
```

---

## 📊 预期效果

### 测试问题1: "支持哪些无人机型号？"
```
【路由决策】: basic_info → P3 (官网)
【检索结果】: 
  - EVO Nest官网: 3 chunks
  - DJI Dock官网: 3 chunks
【信息充分性】: 充分 (6 chunks >= 3)
【答案】: 
  EVO Nest支持EVO II系列无人机 [来源: EVO Nest官网]
  DJI Dock支持Matrice 30系列 [来源: DJI Dock官网]
```

### 测试问题2: "数据传输速度是多少？"
```
【路由决策】: technical → P1 (白皮书)
【检索结果】:
  - EVO Nest技术白皮书: 4 chunks
  - DJI Dock技术白皮书: 4 chunks
【信息充分性】: 充分 (8 chunks >= 3)
【答案】:
  EVO Nest传输速度为150-200 MB/s [来源: EVO Nest技术白皮书, Page 3]
  DJI Dock传输速度为80-120 MB/s [来源: DJI Dock技术白皮书, Page 5]
```

### 测试问题3: "Autel优势在哪？"
```
【路由决策】: comparison → P2+P3 (手册+官网)
【检索结果】:
  - EVO Nest用户手册: 3 chunks
  - DJI Dock用户手册: 3 chunks
  - EVO Nest官网: 2 chunks
  - DJI Dock官网: 2 chunks
【信息充分性】: 充分 (10 chunks >= 3)
【答案】:
  Autel EVO Nest的优势包括:
  1. 传输速度更快 [来源: 技术白皮书对比]
  2. 重量更轻便于部署 [来源: EVO Nest官网]
  3. 充电速度更快 [来源: EVO Nest用户手册, Page 12]
  ...
```

---

现在我将把这个计划转换为编号的顺序清单，并创建TODO文件。

[1 tool called]

---

## ✅ 计划完成总结

我已经创建了详尽的实施计划，包含：

### 📋 工作项清单
- **总计30个工作项**，分为6个阶段：
  1. 环境准备和依赖更新 (3项)
  2. 核心类和状态定义 (5项)
  3. 初始化和向量库加载 (4项)
  4. 图节点实现 (9项)
  5. 可视化和演示 (6项)
  6. 测试和验证 (3项)

### 🎯 核心特性覆盖
- ✅ **条件边**: `check_sufficiency` → `route_after_check` 决策
- ✅ **并行节点**: `retrieve_parallel` 并发查询多个数据源
- ✅ **状态管理**: `GraphState` 跟踪全流程
- ✅ **循环逻辑**: `expand_sources` → `retrieve_parallel` 补充查询

### 📊 技术规格
- **双模型策略**: classifier_llm (deepseek-chat) + generator_llm (deepseek-reasoner)
- **6个数据源**: 复用现有向量库，无需重新创建
- **3种路由规则**: basic_info→P3, technical→P1, comparison→P2+P3
- **补充查询**: 最多3次迭代，逐级扩展数据源

### 📁 输出文件
- ✅ `todo-2025-11-21--16-04.md` - 已创建
- 待创建: `uav-nest-agent-agentic-rag.py` (EXECUTE阶段)
- 待更新: `requirements.txt` (EXECUTE阶段)
- 运行时生成: `agentic-rag-workflow.mmd` (程序运行后)

---

## 📐 计划质量保证

### ✅ 满足RIPER-5协议要求

| 要求 | 完成情况 |
|-----|---------|
| **详尽性** | ✅ 30个具体工作项，每项都有明确目标 |
| **无需创造性决策** | ✅ 每个步骤都有详细说明和技术规格 |
| **顺序清单** | ✅ 按1-30编号，按阶段分组 |
| **TODO文件** | ✅ 已创建`todo-2025-11-21--16-04.md` |
| **包含技术细节** | ✅ 包含Prompt模板、路由规则、代码示例 |
| **可追溯性** | ✅ 每个决策都有清晰的理由和预期效果 |

### 🎓 教学价值保证
- 清晰展示LangGraph相比LangChain的优势
- 完整覆盖"参考资料2-stage1to3"的学习要点
- 能够准确回答3个测试问题
- 满足用户的核心顾虑（清晰标注信息源）

---

**下一步推荐操作**：

1. **进入下一模式的指令**: `ENTER EXECUTE MODE`
   - AI将按照TODO清单逐项实施
   - 创建`uav-nest-agent-agentic-rag.py`
   - 更新`requirements.txt`
   - 在TODO文件中标记完成进度

2. **继续停留在本模式与我讨论**: 如可以将以下内容复制粘贴给AI：
   - "我对计划中的某个部分有疑问..." (指定工作项编号)
   - "我希望调整某个技术细节..." (说明调整内容)
   - "能否解释一下为什么要这样设计..." (提出具体问题)

```