# 多源RAG整合实施清单

**创建时间**: 2025-11-21 10:15  
**更新时间**: 2025-11-21 10:20  
**目标**: 实现基于LangChain的多源RAG系统，对比3种合并策略，展示LangChain的局限性  
**主要文件**: `uav-nest-agent-multi-source.py`  
**文档更新**: `README.md`

---

## 实施清单

### 阶段1: 基础架构搭建

- [ ] 1. 创建新文件`uav-nest-agent-multi-source.py`，复制单源RAG的基础架构（imports、API key管理、FastEmbed配置）
- [ ] 2. 定义`MultiSourceRAGAgent`类的基本结构和6个数据源的配置信息（路径、表名、优先级）

### 阶段2: 数据源加载

- [ ] 3. 实现数据源加载方法1：加载4个Markdown文件（技术白皮书×2 + 官网介绍×2），使用`UnstructuredMarkdownLoader`
- [ ] 4. 实现数据源加载方法2：加载EVO Nest用户手册PDF（`EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf`）
- [ ] 5. 实现数据源加载方法3：加载DJI Dock用户手册PDF并进行关键词过滤（`M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf`）
- [ ] 6. 实现关键词过滤函数`filter_documents_by_keywords()`

### 阶段3: 文本处理与向量化

- [ ] 7. 实现文本分块方法，为所有6个数据源应用`RecursiveCharacterTextSplitter`（chunk_size=1000, chunk_overlap=200）
- [ ] 8. 为每个chunk添加metadata字段：`source_type`、`priority`、`product`、`source_file`
- [ ] 9. 实现向量库创建方法：为6个数据源分别创建独立的LanceDB表
- [ ] 10. 实现向量库加载方法：检查已存在的表并加载（避免重复索引）

### 阶段4: 检索器配置

- [ ] 11. 创建6个独立的retriever，配置参数：`search_type="similarity"`, `k=5`
- [ ] 12. 将6个retriever按优先级分组（P1、P2、P3）

### 阶段5: 策略1实现（简单拼接）

- [ ] 13. 实现策略1方法：`retrieve_strategy_simple_concat()` - 简单拼接所有检索结果
- [ ] 14. 为策略1添加详细日志输出（显示每个数据源的chunk数量）

### 阶段6: 策略3实现（RRF融合）

- [ ] 15. 实现策略3方法：`retrieve_strategy_rrf()` - 使用LangChain的`EnsembleRetriever`进行RRF融合
- [ ] 16. 为策略3添加详细日志输出，并在代码注释中标注"LangChain局限性#1：无法配置权重"

### 阶段7: 策略4实现（优先级过滤）

- [ ] 17. 实现策略4方法：`retrieve_strategy_priority_filter()` - 自定义优先级过滤逻辑
- [ ] 18. 为策略4添加详细日志输出（显示分阶段查询过程），并在代码注释中标注"LangChain局限性#2：无法实现条件分支"

### 阶段8: RAG链构建

- [ ] 19. 设计通用的Prompt模板，要求LLM进行结构化对比分析
- [ ] 20. 实现文档格式化函数`format_docs_with_source()`，显示每个chunk的来源和优先级
- [ ] 21. 为3种策略分别创建RAG链：`rag_chain_simple`、`rag_chain_rrf`、`rag_chain_priority`

### 阶段9: 对比演示功能

- [ ] 22. 实现`compare_strategies()`方法，依次调用3种策略并记录结果
- [ ] 23. 实现对比报告生成功能，输出详细的表格和统计信息
- [ ] 24. 在对比报告中添加"LangChain局限性总结"部分

### 阶段10: 主函数与错误处理

- [ ] 25. 实现`main()`函数，提供交互选项（完整对比/单策略测试/重新索引）
- [ ] 26. 添加错误处理：PDF加载失败、向量库创建失败、API调用失败

### 阶段11: 代码优化与文档

- [ ] 27. 在类的docstring中添加设计说明，解释为什么要这样实现
- [ ] 28. 在多retriever管理代码处添加注释："LangChain局限性#3：缺乏统一的管理接口"

### 阶段12: 测试与验证

- [ ] 29. 运行完整测试：加载6个数据源、创建6个向量库、执行3种策略对比
- [ ] 30. 验证输出结果：检查日志格式、对比报告的完整性、答案质量

### 阶段13: 文档更新

- [ ] 31. 更新README.md：添加"多源RAG演示"章节，说明如何运行`uav-nest-agent-multi-source.py`
- [ ] 32. 在README.md中添加运行示例和预期输出展示
- [ ] 33. 在README.md中添加单源RAG vs 多源RAG的对比说明

---

## 数据源配置

| 序号 | 数据源 | 文件路径 | 表名 | 优先级 |
|-----|--------|---------|------|--------|
| 1 | EVO Nest技术白皮书 | `evo-nest-data-storage-spec.md` | `evo_nest_whitepaper` | P1 |
| 2 | DJI Dock技术白皮书 | `dji-dock-data-storage-spec.md` | `dji_dock_whitepaper` | P1 |
| 3 | EVO Nest用户手册 | `EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf` | `evo_nest_manual` | P2 |
| 4 | DJI Dock用户手册 | `M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf` | `dji_dock_manual` | P2 |
| 5 | EVO Nest官网 | `evo-nest-official-webpage.md` | `evo_nest_webpage` | P3 |
| 6 | DJI Dock官网 | `dji-dock-official-webpage.md` | `dji_dock_webpage` | P3 |

---

## 3种合并策略

### 策略1: 简单拼接
- **方法**: 按优先级顺序直接拼接所有检索结果
- **优点**: 实现简单，保留优先级顺序
- **缺点**: 可能导致context过长

### 策略3: RRF融合
- **方法**: 使用LangChain的`EnsembleRetriever`进行Reciprocal Rank Fusion
- **优点**: 综合考虑所有数据源，避免单一数据源垄断
- **缺点**: 无法配置数据源权重（LangChain局限性）

### 策略4: 优先级过滤
- **方法**: 先查高优先级源，结果不足时才查低优先级源
- **优点**: 充分利用高质量数据，减少噪音
- **缺点**: 需要完全自定义实现（LangChain局限性）

---

## LangChain局限性（预期展示）

1. **局限性#1**: `EnsembleRetriever`无法配置数据源优先级权重
   - 位置: 策略3实现
   
2. **局限性#2**: 标准RAG链不支持条件分支逻辑
   - 位置: 策略4实现
   
3. **局限性#3**: 需要手动管理多个检索器，缺乏统一的管理接口
   - 位置: 检索器创建部分

4. **局限性#4**: 缺乏查询路由功能，无法根据问题类型自动选择数据源
   - 位置: 对比总结部分

5. **局限性#5**: 多检索器的日志输出混乱，难以追踪
   - 位置: 整体实现

---

## 技术参数

- **文本分块**: `chunk_size=1000`, `chunk_overlap=200`
- **每个retriever的k值**: `k=5`（共6个retriever，最多30个chunks）
- **优先级过滤阈值**: `threshold=8`
- **关键词列表**: `["存储", "数据管理", "内存", "SD卡", "数据传输", "备份", "容量"]`

---

## 预期输出示例

```
═══════════════════════════════════════════════════════════════
🎯 多源RAG策略对比实验
═══════════════════════════════════════════════════════════════

问题：EVO Nest机巢的数据存储方案与DJI Dock机场有什么区别？

───────────────────────────────────────────────────────────────
📊 策略1: 简单拼接
───────────────────────────────────────────────────────────────

🔍 检索阶段：
  ✅ P1 (技术白皮书): 10 chunks
  ✅ P2 (用户手册): 10 chunks
  ✅ P3 (官网介绍): 10 chunks
  📦 总计: 30 chunks

💬 生成答案：
[LLM生成的对比分析...]

⏱️  耗时: 15.3秒

───────────────────────────────────────────────────────────────
📊 策略3: RRF融合
───────────────────────────────────────────────────────────────
[类似输出...]

───────────────────────────────────────────────────────────────
📊 策略4: 优先级过滤
───────────────────────────────────────────────────────────────
[类似输出...]

───────────────────────────────────────────────────────────────
📈 策略对比总结
───────────────────────────────────────────────────────────────

⚠️  LangChain在多源RAG场景下的局限性：
1. 需要手动管理多个检索器，缺乏统一的管理接口
2. EnsembleRetriever无法配置数据源权重
3. 无法实现条件查询逻辑（策略4需要完全自定义）
4. 缺乏查询路由功能
5. 多检索器的日志输出混乱
```

---

## README.md 更新内容

### 新增章节：多源RAG演示

在README.md的Quickstart部分后添加以下内容：

```markdown
## 🔬 多源RAG演示（体验LangChain的局限性）

本项目包含两个版本的RAG实现，用于对比单源和多源场景：

| 版本 | 文件 | 数据源数量 | 适用场景 |
|-----|------|-----------|---------|
| 单源RAG | `uav-nest-agent-by-langchain.py` | 1个PDF | 简单问答 |
| 多源RAG | `uav-nest-agent-multi-source.py` | 6个数据源 | 产品对比分析 |

### 运行多源RAG演示

**目的**：对比EVO Nest和DJI Dock的数据存储方案，展示LangChain在多数据源场景下的局限性。

**步骤1：准备数据源**
确保以下文件已存在（已包含在项目中）：
- ✅ `evo-nest-data-storage-spec.md` - EVO Nest技术白皮书
- ✅ `dji-dock-data-storage-spec.md` - DJI Dock技术白皮书
- ✅ `evo-nest-official-webpage.md` - EVO Nest官网介绍
- ✅ `dji-dock-official-webpage.md` - DJI Dock官网介绍
- ✅ `EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf` - EVO Nest用户手册
- ✅ `M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf` - DJI Dock用户手册

**步骤2：运行演示程序**
```bash
# 确保虚拟环境已激活
source .venv/bin/activate

# 运行多源RAG演示（首次运行会创建6个向量库，需要几分钟）
python uav-nest-agent-multi-source.py
```

**步骤3：观察输出**
程序会依次展示3种合并策略的效果：

```
═══════════════════════════════════════════════════════════════
🎯 多源RAG策略对比实验
═══════════════════════════════════════════════════════════════

问题：EVO Nest机巢的数据存储方案与DJI Dock机场有什么区别？

───────────────────────────────────────────────────────────────
📊 策略1: 简单拼接
───────────────────────────────────────────────────────────────

🔍 检索阶段：
  ✅ P1 (技术白皮书): 10 chunks
     - evo_nest_whitepaper: 5 chunks
     - dji_dock_whitepaper: 5 chunks
  ✅ P2 (用户手册): 10 chunks
  ✅ P3 (官网介绍): 10 chunks
  📦 总计: 30 chunks

💬 生成答案：
[详细的产品对比分析...]

───────────────────────────────────────────────────────────────
📊 策略3: RRF融合
───────────────────────────────────────────────────────────────
[RRF融合策略的结果...]

───────────────────────────────────────────────────────────────
📊 策略4: 优先级过滤
───────────────────────────────────────────────────────────────

🔍 阶段1: 查询P1 (技术白皮书) → 10 chunks ✅ 超过阈值
⏭️  跳过P2和P3查询（P1结果已足够）
📦 最终使用: 10 chunks (全部来自技术白皮书)

💬 生成答案：
[基于高质量数据源的精准分析...]

───────────────────────────────────────────────────────────────
📈 策略对比总结
───────────────────────────────────────────────────────────────

⚠️  LangChain在多源RAG场景下的局限性：
1. ❌ 需要手动管理多个检索器，缺乏统一的管理接口
2. ❌ EnsembleRetriever无法配置数据源权重
3. ❌ 无法实现条件查询逻辑（如"先查A，不够再查B"）
4. ❌ 缺乏查询路由功能，无法根据问题类型自动选择数据源
5. ❌ 多检索器的日志输出混乱，难以追踪
```

### 预期观察结果

通过运行多源RAG演示，您会清晰地看到：

**✅ 策略1（简单拼接）的问题**：
- Context包含30个chunks，可能过长导致LLM无法有效利用所有信息
- 低优先级数据源（官网介绍）的营销性内容混入技术对比中

**✅ 策略3（RRF融合）的问题**：
- LangChain的EnsembleRetriever无法为数据源设置优先级权重
- 所有数据源被平等对待，无法体现"技术白皮书>用户手册>官网"的质量差异

**✅ 策略4（优先级过滤）的问题**：
- LangChain的标准RAG链不支持条件分支
- 需要完全自定义实现控制流（100+行代码）
- 无法使用LangChain的Chain抽象

### 单源 vs 多源 RAG 对比

| 维度 | 单源RAG | 多源RAG |
|-----|---------|---------|
| **实现复杂度** | ⭐ 简单 | ⭐⭐⭐⭐⭐ 复杂 |
| **代码量** | ~400行 | ~800行 |
| **向量库数量** | 1个 | 6个 |
| **检索器管理** | 1个retriever | 6个retrievers手动协调 |
| **合并策略** | 无需合并 | 需要自定义3种策略 |
| **LangChain支持度** | ✅ 原生支持 | ⚠️ 部分需要自定义 |
| **适用场景** | 单文档问答 | 多文档对比分析 |

### 为什么需要LangGraph？

通过多源RAG演示，我们发现LangChain在复杂场景下的局限：
- ❌ 缺乏灵活的控制流（条件、循环、分支）
- ❌ 缺乏状态管理（无法记录查询历史）
- ❌ 缺乏动态决策（无法根据结果质量调整策略）

**LangGraph** 正是为了解决这些问题而设计的，它提供：
- ✅ 图结构的工作流编排
- ✅ 状态管理和条件路由
- ✅ 多Agent协作能力

下一步可以探索使用LangGraph重构多源RAG系统，解决上述局限性。
```

### 更新Quickstart部分

在现有Quickstart后添加：

```bash
# 运行多源RAG演示（对比3种合并策略）
python uav-nest-agent-multi-source.py
```

### 更新项目结构

在"项目结构"章节添加：

```
├── 📄 核心代码
│   ├── uav-nest-agent-by-langchain.py      # 单源RAG实现
│   └── uav-nest-agent-multi-source.py       # 多源RAG实现（新增）
```

---

## 注意事项

1. PDF文件如果无法用PyPDFLoader读取，尝试使用`UnstructuredPDFLoader`或`PyMuPDFLoader`
2. 大文件关键词过滤在chunk级别进行，不是page级别
3. 向量库路径：`tmp/lancedb/{table_name}/`
4. DeepSeek API可能有速率限制，策略调用之间添加延迟
5. 同时加载6个向量库需要足够内存

---

## 审查记录

*本部分将在EXECUTE模式完成后填写*

