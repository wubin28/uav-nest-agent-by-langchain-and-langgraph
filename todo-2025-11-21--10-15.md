# 多源RAG整合实施清单

**创建时间**: 2025-11-21 10:15  
**目标**: 实现基于LangChain的多源RAG系统，对比3种合并策略，展示LangChain的局限性  
**文件**: `uav-nest-agent-multi-source.py`

---

## 实施清单

### 阶段1: 基础架构搭建

- [ ] 1. 创建新文件`uav-nest-agent-multi-source.py`，复制单源RAG的基础架构（imports、API key管理、FastEmbed配置）
- [ ] 2. 定义`MultiSourceRAGAgent`类的基本结构和6个数据源的配置信息（路径、表名、优先级）

### 阶段2: 数据源加载

- [ ] 3. 实现数据源加载方法1：加载4个Markdown文件（技术白皮书×2 + 官网介绍×2），使用`UnstructuredMarkdownLoader`
- [ ] 4. 实现数据源加载方法2：加载EVO Nest用户手册PDF（`EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf`）
- [ ] 5. 实现数据源加载方法3：加载DJI Dock用户手册PDF并进行关键词过滤（`M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf`）
- [ ] 6. 实现关键词过滤函数`filter_documents_by_keywords()`

### 阶段3: 文本处理与向量化

- [ ] 7. 实现文本分块方法，为所有6个数据源应用`RecursiveCharacterTextSplitter`（chunk_size=1000, chunk_overlap=200）
- [ ] 8. 为每个chunk添加metadata字段：`source_type`、`priority`、`product`、`source_file`
- [ ] 9. 实现向量库创建方法：为6个数据源分别创建独立的LanceDB表
- [ ] 10. 实现向量库加载方法：检查已存在的表并加载（避免重复索引）

### 阶段4: 检索器配置

- [ ] 11. 创建6个独立的retriever，配置参数：`search_type="similarity"`, `k=5`
- [ ] 12. 将6个retriever按优先级分组（P1、P2、P3）

### 阶段5: 策略1实现（简单拼接）

- [ ] 13. 实现策略1方法：`retrieve_strategy_simple_concat()` - 简单拼接所有检索结果
- [ ] 14. 为策略1添加详细日志输出（显示每个数据源的chunk数量）

### 阶段6: 策略3实现（RRF融合）

- [ ] 15. 实现策略3方法：`retrieve_strategy_rrf()` - 使用LangChain的`EnsembleRetriever`进行RRF融合
- [ ] 16. 为策略3添加详细日志输出，并在代码注释中标注"LangChain局限性#1：无法配置权重"

### 阶段7: 策略4实现（优先级过滤）

- [ ] 17. 实现策略4方法：`retrieve_strategy_priority_filter()` - 自定义优先级过滤逻辑
- [ ] 18. 为策略4添加详细日志输出（显示分阶段查询过程），并在代码注释中标注"LangChain局限性#2：无法实现条件分支"

### 阶段8: RAG链构建

- [ ] 19. 设计通用的Prompt模板，要求LLM进行结构化对比分析
- [ ] 20. 实现文档格式化函数`format_docs_with_source()`，显示每个chunk的来源和优先级
- [ ] 21. 为3种策略分别创建RAG链：`rag_chain_simple`、`rag_chain_rrf`、`rag_chain_priority`

### 阶段9: 对比演示功能

- [ ] 22. 实现`compare_strategies()`方法，依次调用3种策略并记录结果
- [ ] 23. 实现对比报告生成功能，输出详细的表格和统计信息
- [ ] 24. 在对比报告中添加"LangChain局限性总结"部分

### 阶段10: 主函数与错误处理

- [ ] 25. 实现`main()`函数，提供交互选项（完整对比/单策略测试/重新索引）
- [ ] 26. 添加错误处理：PDF加载失败、向量库创建失败、API调用失败

### 阶段11: 代码优化与文档

- [ ] 27. 在类的docstring中添加设计说明，解释为什么要这样实现
- [ ] 28. 在多retriever管理代码处添加注释："LangChain局限性#3：缺乏统一的管理接口"

### 阶段12: 测试与验证

- [ ] 29. 运行完整测试：加载6个数据源、创建6个向量库、执行3种策略对比
- [ ] 30. 验证输出结果：检查日志格式、对比报告的完整性、答案质量

---

## 数据源配置

| 序号 | 数据源 | 文件路径 | 表名 | 优先级 |
|-----|--------|---------|------|--------|
| 1 | EVO Nest技术白皮书 | `evo-nest-data-storage-spec.md` | `evo_nest_whitepaper` | P1 |
| 2 | DJI Dock技术白皮书 | `dji-dock-data-storage-spec.md` | `dji_dock_whitepaper` | P1 |
| 3 | EVO Nest用户手册 | `EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf` | `evo_nest_manual` | P2 |
| 4 | DJI Dock用户手册 | `M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf` | `dji_dock_manual` | P2 |
| 5 | EVO Nest官网 | `evo-nest-official-webpage.md` | `evo_nest_webpage` | P3 |
| 6 | DJI Dock官网 | `dji-dock-official-webpage.md` | `dji_dock_webpage` | P3 |

---

## 3种合并策略

### 策略1: 简单拼接
- **方法**: 按优先级顺序直接拼接所有检索结果
- **优点**: 实现简单，保留优先级顺序
- **缺点**: 可能导致context过长

### 策略3: RRF融合
- **方法**: 使用LangChain的`EnsembleRetriever`进行Reciprocal Rank Fusion
- **优点**: 综合考虑所有数据源，避免单一数据源垄断
- **缺点**: 无法配置数据源权重（LangChain局限性）

### 策略4: 优先级过滤
- **方法**: 先查高优先级源，结果不足时才查低优先级源
- **优点**: 充分利用高质量数据，减少噪音
- **缺点**: 需要完全自定义实现（LangChain局限性）

---

## LangChain局限性（预期展示）

1. **局限性#1**: `EnsembleRetriever`无法配置数据源优先级权重
   - 位置: 策略3实现
   
2. **局限性#2**: 标准RAG链不支持条件分支逻辑
   - 位置: 策略4实现
   
3. **局限性#3**: 需要手动管理多个检索器，缺乏统一的管理接口
   - 位置: 检索器创建部分

4. **局限性#4**: 缺乏查询路由功能，无法根据问题类型自动选择数据源
   - 位置: 对比总结部分

5. **局限性#5**: 多检索器的日志输出混乱，难以追踪
   - 位置: 整体实现

---

## 技术参数

- **文本分块**: `chunk_size=1000`, `chunk_overlap=200`
- **每个retriever的k值**: `k=5`（共6个retriever，最多30个chunks）
- **优先级过滤阈值**: `threshold=8`
- **关键词列表**: `["存储", "数据管理", "内存", "SD卡", "数据传输", "备份", "容量"]`

---

## 预期输出示例

```
═══════════════════════════════════════════════════════════════
🎯 多源RAG策略对比实验
═══════════════════════════════════════════════════════════════

问题：EVO Nest机巢的数据存储方案与DJI Dock机场有什么区别？

───────────────────────────────────────────────────────────────
📊 策略1: 简单拼接
───────────────────────────────────────────────────────────────

🔍 检索阶段：
  ✅ P1 (技术白皮书): 10 chunks
  ✅ P2 (用户手册): 10 chunks
  ✅ P3 (官网介绍): 10 chunks
  📦 总计: 30 chunks

💬 生成答案：
[LLM生成的对比分析...]

⏱️  耗时: 15.3秒

───────────────────────────────────────────────────────────────
📊 策略3: RRF融合
───────────────────────────────────────────────────────────────
[类似输出...]

───────────────────────────────────────────────────────────────
📊 策略4: 优先级过滤
───────────────────────────────────────────────────────────────
[类似输出...]

───────────────────────────────────────────────────────────────
📈 策略对比总结
───────────────────────────────────────────────────────────────

⚠️  LangChain在多源RAG场景下的局限性：
1. 需要手动管理多个检索器，缺乏统一的管理接口
2. EnsembleRetriever无法配置数据源权重
3. 无法实现条件查询逻辑（策略4需要完全自定义）
4. 缺乏查询路由功能
5. 多检索器的日志输出混乱
```

---

## 注意事项

1. PDF文件如果无法用PyPDFLoader读取，尝试使用`UnstructuredPDFLoader`或`PyMuPDFLoader`
2. 大文件关键词过滤在chunk级别进行，不是page级别
3. 向量库路径：`tmp/lancedb/{table_name}/`
4. DeepSeek API可能有速率限制，策略调用之间添加延迟
5. 同时加载6个向量库需要足够内存

---

## 审查记录

*本部分将在EXECUTE模式完成后填写*

