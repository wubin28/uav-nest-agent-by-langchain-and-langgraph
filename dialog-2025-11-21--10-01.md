## Me:

```
ENTER PLAN MODE
```

## Cursor with claude sonnet 4.5:

```
[MODE: PLAN]

## 多源RAG整合实施计划

基于INNOVATE模式确定的方案A（平行多检索器 + 三策略对比），我将制定详细的实施计划。

---

### 📐 总体架构设计

**文件结构**：
```
uav-nest-agent-multi-source.py  # 新建文件
tmp/lancedb/
  ├── evo_nest_whitepaper/      # 6个独立向量库
  ├── dji_dock_whitepaper/
  ├── evo_nest_manual/
  ├── dji_dock_manual/
  ├── evo_nest_webpage/
  └── dji_dock_webpage/
```

**核心类设计**：
```
MultiSourceRAGAgent
  ├── 数据源配置（6个）
  ├── 向量库管理器（为每个数据源创建独立的LanceDB表）
  ├── 检索器管理器（管理6个独立retriever）
  ├── 合并策略1：简单拼接
  ├── 合并策略3：RRF融合（使用LangChain的EnsembleRetriever）
  ├── 合并策略4：优先级过滤（自定义实现）
  └── 对比演示方法（调用3种策略并展示差异）
```

---

### 📋 详细实施步骤

#### 阶段1：数据源准备与预处理

**步骤1.1**：处理Markdown数据源（技术白皮书 + 官网介绍）
- 读取`evo-nest-data-storage-spec.md`
- 读取`dji-dock-data-storage-spec.md`
- 读取`evo-nest-official-webpage.md`
- 读取`dji-dock-official-webpage.md`
- 使用`UnstructuredMarkdownLoader`加载内容
- 为每个文档添加metadata：`source_type`, `priority`, `product`

**步骤1.2**：处理EVO Nest用户手册PDF
- 使用`PyPDFLoader`加载`EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf`
- 由于是二进制PDF，需要完整加载（不做关键词过滤）
- 添加metadata：`source_type="manual"`, `priority=2`, `product="evo_nest"`

**步骤1.3**：处理DJI Dock用户手册PDF（关键词过滤）
- 使用`PyPDFLoader`加载`M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf`
- 由于文件过大，加载后需要进行关键词过滤
- 过滤关键词：`["存储", "数据管理", "内存", "SD卡", "数据传输", "备份", "容量"]`
- 只保留包含这些关键词的页面或chunk
- 添加metadata：`source_type="manual"`, `priority=2`, `product="dji_dock"`

**步骤1.4**：文本分块策略
- 对所有文档使用`RecursiveCharacterTextSplitter`
- 配置参数：
  - `chunk_size=1000`（比单源RAG小一些，因为要合并多个数据源）
  - `chunk_overlap=200`
  - `separators=["\n\n", "\n", "。", "；", " ", ""]`（支持中英文）

#### 阶段2：向量库创建与索引

**步骤2.1**：创建6个独立的LanceDB表
- 表1：`evo_nest_whitepaper` - 存储EVO Nest技术白皮书
- 表2：`dji_dock_whitepaper` - 存储DJI Dock技术白皮书
- 表3：`evo_nest_manual` - 存储EVO Nest用户手册
- 表4：`dji_dock_manual` - 存储DJI Dock用户手册（已过滤）
- 表5：`evo_nest_webpage` - 存储EVO Nest官网介绍
- 表6：`dji_dock_webpage` - 存储DJI Dock官网介绍

**步骤2.2**：使用FastEmbed进行向量化
- 复用单源RAG中的`FastEmbedEmbeddings`配置
- 确保所有6个表使用相同的embedding模型（保证向量空间一致性）

**步骤2.3**：批量索引并验证
- 对每个数据源执行`LanceDB.from_documents()`
- 验证每个表的文档数量
- 输出索引统计信息：
  ```
  ✅ evo_nest_whitepaper: 45 chunks
  ✅ dji_dock_whitepaper: 52 chunks
  ✅ evo_nest_manual: 120 chunks (estimated)
  ✅ dji_dock_manual: 35 chunks (filtered)
  ✅ evo_nest_webpage: 18 chunks
  ✅ dji_dock_webpage: 22 chunks
  ```

#### 阶段3：检索器配置

**步骤3.1**：创建6个独立的检索器
- 为每个LanceDB表创建retriever
- 配置参数：
  - `search_type="similarity"`
  - `search_kwargs={"k": 5}`（每个数据源返回5个结果，共30个）

**步骤3.2**：按优先级分组
- P1组（最高优先级）：`[evo_nest_whitepaper_retriever, dji_dock_whitepaper_retriever]`
- P2组（中优先级）：`[evo_nest_manual_retriever, dji_dock_manual_retriever]`
- P3组（低优先级）：`[evo_nest_webpage_retriever, dji_dock_webpage_retriever]`

#### 阶段4：合并策略实现

**步骤4.1**：实现策略1 - 简单拼接
- 定义方法`retrieve_strategy_simple_concat(query: str) -> List[Document]`
- 流程：
  1. 并行查询6个retriever
  2. 按优先级排序：P1结果 → P2结果 → P3结果
  3. 直接拼接所有结果
  4. 返回拼接后的文档列表
- 添加详细日志：
  ```
  [策略1: 简单拼接]
  📊 检索统计：
    - P1 (技术白皮书): 10 chunks (EVO:5, DJI:5)
    - P2 (用户手册): 10 chunks (EVO:5, DJI:5)
    - P3 (官网介绍): 10 chunks (EVO:5, DJI:5)
    - 总计: 30 chunks
  ```

**步骤4.2**：实现策略3 - RRF融合（使用LangChain的EnsembleRetriever）
- 定义方法`retrieve_strategy_rrf(query: str) -> List[Document]`
- 流程：
  1. 使用`EnsembleRetriever.from_retrievers()`合并6个retriever
  2. 设置RRF参数：`weights=[1.0] * 6`（平等权重）
  3. 执行检索
  4. 返回融合后的文档列表
- 添加详细日志：
  ```
  [策略3: RRF融合]
  ⚠️  LangChain的EnsembleRetriever无法配置数据源优先级权重
  📊 检索统计：
    - 融合后返回: 20 chunks (LangChain自动去重和重排序)
    - 数据源分布: P1:8, P2:7, P3:5
  ```
- **在代码注释中标注局限性**：
  ```python
  # ⚠️ LangChain局限性 #1: EnsembleRetriever无法为不同数据源设置优先级权重
  # 所有retriever被平等对待，无法体现技术白皮书>用户手册>官网的质量差异
  ```

**步骤4.3**：实现策略4 - 优先级过滤（自定义实现）
- 定义方法`retrieve_strategy_priority_filter(query: str, threshold: int = 8) -> List[Document]`
- 流程：
  1. 先查询P1组（技术白皮书）
  2. 如果P1结果数量 >= threshold，只使用P1结果
  3. 否则，查询P2组（用户手册）
  4. 如果P1+P2 >= threshold，使用P1+P2
  5. 否则，查询P3组（官网）并使用全部结果
  6. 返回过滤后的文档列表
- 添加详细日志：
  ```
  [策略4: 优先级过滤]
  🔍 阶段1: 查询P1 (技术白皮书) → 10 chunks ✅ 超过阈值
  ⏭️  跳过P2和P3查询（P1结果已足够）
  📊 最终使用: 10 chunks (全部来自技术白皮书)
  ```
- **在代码注释中标注局限性**：
  ```python
  # ⚠️ LangChain局限性 #2: 标准RAG链不支持条件分支逻辑
  # 这种"先查A，不够再查B"的模式需要完全自定义实现
  # 无法使用LangChain的Chain抽象，必须手动编写控制流
  ```

#### 阶段5：RAG链构建

**步骤5.1**：为每种策略创建独立的RAG链
- 策略1的RAG链：`rag_chain_simple`
- 策略3的RAG链：`rag_chain_rrf`
- 策略4的RAG链：`rag_chain_priority`

**步骤5.2**：设计通用的Prompt模板
```python
template = """你是一个专业的无人机产品对比分析专家，擅长比较EVO Nest和DJI Dock的技术方案。

请根据以下产品文档来回答问题。文档按优先级排序（技术白皮书 > 用户手册 > 官网介绍）。

产品文档：
{context}

问题：{question}

请提供结构化的对比分析，包括：
1. EVO Nest的方案特点
2. DJI Dock的方案特点
3. 两者的关键差异
4. 引用具体的数据来源（标注来自哪个文档）

回答："""
```

**步骤5.3**：实现文档格式化函数
```python
def format_docs_with_source(docs: List[Document]) -> str:
    """格式化文档，显示来源和优先级"""
    # 按source_type分组
    # 输出格式：
    # === P1: 技术白皮书 ===
    # [EVO Nest - evo-nest-data-storage-spec.md]
    # 内容...
```

#### 阶段6：对比演示功能

**步骤6.1**：实现`compare_strategies()`方法
- 输入：目标问题（"EVO Nest机巢的数据存储方案与DJI Dock机场有什么区别？"）
- 流程：
  1. 依次调用策略1、策略3、策略4
  2. 记录每种策略的检索结果（chunks数量、数据源分布）
  3. 记录每种策略的最终答案
  4. 生成对比报告

**步骤6.2**：设计详细的输出格式
```
═══════════════════════════════════════════════════════════════
🎯 多源RAG策略对比实验
═══════════════════════════════════════════════════════════════

问题：EVO Nest机巢的数据存储方案与DJI Dock机场有什么区别？

───────────────────────────────────────────────────────────────
📊 策略1: 简单拼接
───────────────────────────────────────────────────────────────

🔍 检索阶段：
  ✅ P1 (技术白皮书): 10 chunks
     - evo_nest_whitepaper: 5 chunks
     - dji_dock_whitepaper: 5 chunks
  ✅ P2 (用户手册): 10 chunks
     - evo_nest_manual: 5 chunks
     - dji_dock_manual: 5 chunks
  ✅ P3 (官网介绍): 10 chunks
     - evo_nest_webpage: 5 chunks
     - dji_dock_webpage: 5 chunks
  📦 总计: 30 chunks

💬 生成答案：
[答案内容...]

⏱️  耗时: 15.3秒

───────────────────────────────────────────────────────────────
📊 策略3: RRF融合
───────────────────────────────────────────────────────────────
[类似格式...]

───────────────────────────────────────────────────────────────
📊 策略4: 优先级过滤
───────────────────────────────────────────────────────────────
[类似格式...]

───────────────────────────────────────────────────────────────
📈 策略对比总结
───────────────────────────────────────────────────────────────

| 指标 | 策略1 | 策略3 | 策略4 |
|------|-------|-------|-------|
| 检索chunks数 | 30 | 20 | 10 |
| 高优先级占比 | 33% | 40% | 100% |
| 生成耗时 | 15.3s | 12.1s | 8.7s |
| 答案质量 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

💡 观察与分析：
- 策略1由于context过长，可能包含冗余信息
- 策略3利用RRF融合，但无法体现优先级差异
- 策略4充分利用高质量数据源，答案最精准

⚠️  LangChain在多源RAG场景下的局限性：
1. 需要手动管理多个检索器，缺乏统一的管理接口
2. EnsembleRetriever无法配置数据源权重
3. 无法实现条件查询逻辑（策略4需要完全自定义）
4. 缺乏查询路由功能，无法根据问题类型自动选择数据源
5. 多检索器的日志输出混乱，难以追踪
```

#### 阶段7：代码优化与注释

**步骤7.1**：在关键位置添加LangChain局限性注释
- 在创建6个retriever的代码块添加注释：
  ```python
  # ⚠️ LangChain局限性 #3: 需要手动管理多个检索器
  # 没有统一的MultiRetrieverManager类，代码重复度高
  ```
- 在EnsembleRetriever使用处添加注释（已在步骤4.2完成）
- 在自定义条件查询处添加注释（已在步骤4.3完成）

**步骤7.2**：在类的docstring中说明设计目的
```python
"""
MultiSourceRAGAgent - 多源RAG代理（教学演示版）

本实现旨在展示LangChain在多数据源场景下的局限性：
1. 需要手动管理6个独立的向量库和检索器
2. EnsembleRetriever无法配置数据源优先级权重
3. 无法实现条件查询（如"先查A，不够再查B"）
4. 缺乏查询路由（无法根据问题自动选择数据源）

这些问题为后续学习LangGraph提供了动机。
"""
```

**步骤7.3**：添加详细的日志输出
- 使用Python的`logging`模块
- 设置日志级别：`INFO`（显示检索统计）、`DEBUG`（显示chunk内容）
- 为每个关键步骤添加日志

#### 阶段8：主函数与演示

**步骤8.1**：实现`main()`函数
```python
def main():
    # 1. 初始化Agent
    # 2. 加载并索引6个数据源（如果向量库不存在）
    # 3. 运行策略对比演示
    # 4. 输出对比报告
```

**步骤8.2**：添加交互选项
- 选项1：运行完整的3策略对比
- 选项2：只运行单个策略（用于快速测试）
- 选项3：重新索引数据源（force_reload）

**步骤8.3**：添加错误处理
- 捕获PDF加载失败
- 捕获向量库创建失败
- 捕获DeepSeek API调用失败
- 提供友好的错误提示

---

### 🔧 技术实现细节

#### 关键词过滤实现（针对DJI Dock大型PDF）
```python
def filter_documents_by_keywords(
    documents: List[Document],
    keywords: List[str]
) -> List[Document]:
    """过滤包含关键词的文档"""
    filtered = []
    for doc in documents:
        content_lower = doc.page_content.lower()
        if any(keyword in content_lower for keyword in keywords):
            filtered.append(doc)
    return filtered
```

#### RRF融合的替代方案（如果EnsembleRetriever不好用）
```python
def rrf_fusion(
    results_lists: List[List[Document]],
    k: int = 60
) -> List[Document]:
    """手动实现RRF融合算法"""
    # RRF公式: score = Σ(1 / (rank + k))
    # 实现细节...
```

---

### 📝 实施清单

以下是按顺序执行的工作项清单：

1. 创建新文件`uav-nest-agent-multi-source.py`，复制单源RAG的基础架构（imports、API key管理、FastEmbed配置）

2. 定义`MultiSourceRAGAgent`类的基本结构和6个数据源的配置信息（路径、表名、优先级）

3. 实现数据源加载方法1：加载4个Markdown文件（技术白皮书×2 + 官网介绍×2），使用`UnstructuredMarkdownLoader`

4. 实现数据源加载方法2：加载EVO Nest用户手册PDF（`EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf`）

5. 实现数据源加载方法3：加载DJI Dock用户手册PDF并进行关键词过滤（`M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf`）

6. 实现关键词过滤函数`filter_documents_by_keywords()`

7. 实现文本分块方法，为所有6个数据源应用`RecursiveCharacterTextSplitter`（chunk_size=1000, chunk_overlap=200）

8. 为每个chunk添加metadata字段：`source_type`、`priority`、`product`、`source_file`

9. 实现向量库创建方法：为6个数据源分别创建独立的LanceDB表

10. 实现向量库加载方法：检查已存在的表并加载（避免重复索引）

11. 创建6个独立的retriever，配置参数：`search_type="similarity"`, `k=5`

12. 将6个retriever按优先级分组（P1、P2、P3）

13. 实现策略1方法：`retrieve_strategy_simple_concat()` - 简单拼接所有检索结果

14. 为策略1添加详细日志输出（显示每个数据源的chunk数量）

15. 实现策略3方法：`retrieve_strategy_rrf()` - 使用LangChain的`EnsembleRetriever`进行RRF融合

16. 为策略3添加详细日志输出，并在代码注释中标注"LangChain局限性#1：无法配置权重"

17. 实现策略4方法：`retrieve_strategy_priority_filter()` - 自定义优先级过滤逻辑

18. 为策略4添加详细日志输出（显示分阶段查询过程），并在代码注释中标注"LangChain局限性#2：无法实现条件分支"

19. 设计通用的Prompt模板，要求LLM进行结构化对比分析

20. 实现文档格式化函数`format_docs_with_source()`，显示每个chunk的来源和优先级

21. 为3种策略分别创建RAG链：`rag_chain_simple`、`rag_chain_rrf`、`rag_chain_priority`

22. 实现`compare_strategies()`方法，依次调用3种策略并记录结果

23. 实现对比报告生成功能，输出详细的表格和统计信息

24. 在对比报告中添加"LangChain局限性总结"部分

25. 实现`main()`函数，提供交互选项（完整对比/单策略测试/重新索引）

26. 添加错误处理：PDF加载失败、向量库创建失败、API调用失败

27. 在类的docstring中添加设计说明，解释为什么要这样实现

28. 在多retriever管理代码处添加注释："LangChain局限性#3：缺乏统一的管理接口"

29. 运行完整测试：加载6个数据源、创建6个向量库、执行3种策略对比

30. 验证输出结果：检查日志格式、对比报告的完整性、答案质量

31. 创建todo文件：将本计划保存为`todo-2025-11-21--10-15.md`（使用当前时间戳）

---

### ⚠️ 注意事项

1. **PDF处理**：如果`EN_EVO-Nest-Kit-User-Manual_V1.0.1.pdf`无法用PyPDFLoader读取（二进制格式），考虑使用`UnstructuredPDFLoader`或`PyMuPDFLoader`

2. **大文件过滤**：`M30_Series_Dock_Bundle_User_Manual_v1.8_CHS.pdf`的关键词过滤需要在chunk级别进行，而不是page级别，以提高准确性

3. **向量库路径**：6个向量库存储在`tmp/lancedb/`下的不同子目录，确保路径结构清晰

4. **API限流**：DeepSeek API可能有速率限制，3次策略调用需要添加适当的延迟

5. **内存管理**：同时加载6个向量库可能占用较多内存，确保系统有足够资源

---

现在我将创建todo文件...

[1 tool called]

## ✅ 计划制定完成

我已经完成了详细的实施计划，并将其保存到 `todo-2025-11-21--10-15.md` 文件中。

### 📋 计划摘要

**总共30个实施步骤**，分为12个阶段：

1. **基础架构搭建** (2步)
2. **数据源加载** (4步)
3. **文本处理与向量化** (4步)
4. **检索器配置** (2步)
5. **策略1实现 - 简单拼接** (2步)
6. **策略3实现 - RRF融合** (2步)
7. **策略4实现 - 优先级过滤** (2步)
8. **RAG链构建** (3步)
9. **对比演示功能** (3步)
10. **主函数与错误处理** (2步)
11. **代码优化与文档** (2步)
12. **测试与验证** (2步)

### 🎯 核心设计

- **6个独立向量库**：便于展示LangChain的多源管理复杂性
- **3种合并策略**：从简单到复杂，清晰展示差异
- **详细日志输出**：每个策略显示检索统计、数据源分布、相似度分数
- **局限性标注**：在3个关键位置通过代码注释标注LangChain的5个局限性

### 📂 生成的文件

- ✅ `todo-2025-11-21--10-15.md` - 详细的实施清单（已创建）
- 待创建：`uav-nest-agent-multi-source.py` - 多源RAG实现（在EXECUTE模式中创建）

---

## 📌 下一步推荐操作

**PLAN模式已完成**，所有实施步骤已详细规划并保存到todo文件中。

**1. 进入EXECUTE模式**（推荐）：如果您认可此计划，请将以下内容复制粘贴给AI
```
ENTER EXECUTE MODE
```

**2. 继续讨论PLAN模式**：如果您对计划有疑问或需要调整，请将以下内容复制粘贴给AI
```
我不希望你为人类实现本业务需求制定计划。我希望看到你为你自己这位AI进行"LangChain进阶之多源RAG整合"的实施计划，且只列出工作项清单即可，无须预估每个工作项的时长。请基于这一点，将计划转换为带编号的顺序清单，每个操作作为单独的项目。然后在项目根文件夹中创建一个名为"todo-yyyy-mm-dd--hh--mm.md"的文件，其中 yyyy-mm-dd--hh-mm 是当前时间戳（例如："todo-2025-09-30--14-23.md"），重新执行PLAN模式。
```

💡 **提示**：计划已经非常详细，建议直接进入EXECUTE模式开始实施。
```